\documentclass{llncs}
%\pdfoutput=1

\DeclareUnicodeCharacter{2009}{\,}

\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{algorithmic}
\usepackage{algorithm}
%\usepackage{algorithmicx,algpseudocode}
\usepackage[makeroom]{cancel}
\usepackage{pdflscape}
\usepackage{tabularx}
\usepackage{mathtools}

\usepackage{longtable}

\usepackage{tikz}
\usetikzlibrary{matrix,positioning,arrows,decorations.pathmorphing,shapes}
\usepackage{bbm}\usepackage{hhline}
\usetikzlibrary{calc,arrows,automata}
\usetikzlibrary{matrix,positioning,arrows,decorations.pathmorphing,shapes}

\newtheorem{thm}{Theorem}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\tolerance=1
\emergencystretch=\maxdimen
\hyphenpenalty=10000
\hbadness=10000

\providecommand{\abs}[1]{\lvert#1\rvert}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\newcommand{\G} {\mathcal{G}}
\newtheorem{Prop}{Proposition}

%\algrenewcommand{\algorithmiccomment}[1]{\hfill$\blacktriangleright$ #1}

\begin{document}
%

\mainmatter              % start of the contributions
%
\title{A GRASP/VND Heuristic for the Generalized Steiner Problem with Node-Connectivity Constraints and Hostile Reliability}

\titlerunning{A GRASP/VND Heuristic for the GSPNCHR}  % abbreviated title (for running head)

\author{Sebasti\'an Laborde \and Franco Robledo \and\\
  Pablo Romero \and Omar Viera}
%
\authorrunning{Sebasti\'an Laborde et al.} % abbreviated author list (for running head)

%
\institute{Instituto de Computaci\'on, INCO\\
Facultad de Ingenier\'ia - Universidad de la Rep\'ublica\\
Montevideo Uruguay\\
\email{(nlaborde,frobledo,promero,viera)@fing.edu.uy}\\
}

\maketitle              % typeset the title of the contribution

\begin{abstract}
The object under study is a combinatorial optimization problem motivated by the topological network design of 
communication systems, meeting reliability constraints. Specifically, we introduce the 
Generalized Steiner Problem with Node-Connectivity Constraints and Hostile Reliability, or GSPNCHR for short. 
Since the GSPNCHR belongs to the class of $\mathcal{NP}$-Hard problems, approximative algorithms are adequate for 
medium and large-sized networks. As a consequence, we develop a GRASP/VND methodology. 
The VND includes three local searches, that replace special elementary paths or trees, preserving feasibility. Our goal is to find a minimum-cost solution, meeting a reliability threshold, where both nodes and links may fail with given probabilities. We adapted TSPLIB  benchmark in order to highlight 
the effectiveness of our proposal. The results suggest that our heuristic is cost-effective, providing highly-reliable networks.
\keywords{Combinatorial Optimization Problem, Computational Complexity, Network Reliability, GSPNCHR, GRASP, VND.}
\end{abstract}

\section{Motivation}\label{sect:intro}
Currently, the backbone of the Internet infrastructure is supported by fiber-optics communication. Fiber-To-The-Home (FTTH) services have a large penetration throughout the world, and provides high data rates to the final customers. 
However, there are several shortcomings that should be addressed urgently. The physical design of FTTH is not suitable for 
large-scale natural disasters and/or malicious attacks~\cite{116}. The monitoring and detection of failures are sometimes slow, and a service disruption of hours is extremely harmful for business models. Furthermore, FTTH services are suffering the capacity crunch problem, and elastic optical networks combined with smart traffic engineering and additional redundancy is currently in order.

Consequently, a smart augmentation of the physical network is mandatory. Since the deployment of fiber-optics is an important economical investment, the topological network design of FTTH networks should be revisited. The goal is to interconnect 
distinguished nodes, called terminals, using large level of redundancy, and simultaneously, meeting large reliable constraints.

Reliability analysis deals with probabilistic failures on the components of a system. The reliability is precisely the 
probability of correct operation of the whole system, subject to random failures. Here, we consider a realistic \emph{hostile model}, where both nodes and links could fail. Our goal is to understand the cost-reliability trade-off, and how the reliability is naturally increased adding levels of redundancy between distinguished terminals. 
The contributions of this paper can be summarized in the following items:
\begin{enumerate}
\item The Generalized Steiner Problem with Node-Connectivity Constraints and Hostile Reliability (GSPNCHR), is introduced. 
\item We formally prove that the GSPNCHR belongs to the $\mathcal{NP}$-Hard class. 
\item As a consequence, a GRASP/VND methodology is proposed.
\item Our results highlight that the model is robust under non-terminal node-failures, rather than link-failures.
\end{enumerate}

The document is organized in the following manner. The related work is presented in Section~\ref{work}. 
A formal description for the GSPNCHR is presented in Section~\ref{problem}; its $\mathcal{NP}$-Hardness is also established. 
A GRASP/VND solution is introduced in Section~\ref{solution}. 
Numerical results are presented in Section~\ref{results}. 
Section~\ref{conclusions} contains concluding remarks and trends for future work. 


\section{Related Work} \label{work}
Here, we extend the Generalized Steiner Problem (GSP), adding node-connectivity requirements and a hostile network reliability model with probabilistic failures on its components. We cover the main body of related works in the 
fields of network reliability analysis, topological network design and joint problems from the scientific literature. 

Scarce works jointly deal with a topological network optimization under reliability constraints. Javiera Barrera et al. proposed a topological network optimization, trying to minimize costs subject to $K$-terminal reliability constraints~\cite{106}. The authors consider Sample Average Approximation (SAA) method, which is a powerful tool for  stochastic optimization and for the resolution of $\mathcal{NP}$-Hard combinatorial problems with a target probability maximization~\cite{112}. They conclude that suboptimal solutions could be found if dependent failures are ignored in the model. The scientific literature also offers topological optimization problems meeting reliability constraints, or reliability maximization under budget constraints, which is known as network synthesis. 
The reader can find a survey on the synthesis in network reliability in~\cite{113}. 
More recent works propose a reliability optimization in general stochastic binary systems~\cite{107}, even under the introduction of Sample Average Approximation~\cite{114}. Building uniformly most-reliable graphs is an active and challenging research field, where the goal is to find graphs with fixed nodes and links with maximum reliability evaluation in a uniform sense. 
%There are pairs of nodes and links where such uniformly most-reliable graphs do not exist~\cite{108}. 
The interested reader can consult~\cite{115} for conjectures in this field. A close problem to ours is to consider topological transformations (i.e., moving links or path/tree replacements) in order to increase the reliability measure. This problem is not mature, and a recent work propose a novel reliability-increasing network transformation~\cite{110}. There, E. Canale et al. show that any graph with a cut-point can be transformed into a biconnected graph with greater reliability. Using this remarkable property, our design does not include cut-points. 


Most works in the field of network reliability analysis deal with its evaluation rather than its maximization. The literature on network reliability evaluation is abundant, and here we can mention distinguished works on this field. A trade-off between accuracy and computational feasibility is met by simulations, 
given the hardness of the classical network reliability models~\cite{9}. Macroscopically, Monte Carlo methods 
consider independent replications of a complex system, and by means of statistical laws find pointwise 
estimations, in order to make decisions on the system. The reader is invited to consult an excellent book on 
Monte Carlo methods authored by Fishman~\cite{105}, which was inspirational for network reliability, numerical integration, statistics and other fields of knowledge. In our particular case we deal with the 
hostile network reliability model, where both links and non-terminal nodes fail independently. Its reliability evaluation belongs to the class of $\mathcal{NP}$-Hard problems as well~\cite{9}. Recursive Variance Reduction (RVR) is an outstanding technique for the reliability estimation~\cite{85}. This formulation allows a meaningful variance reduction, and the product between time and variance is also reduced when compared to Crude Monte Carlo (CMC). Furthermore, the variance is mathematically proved to be always better in RVR than in CMC. More recently, the applicability of RVR is extended to Stochastic Monotone Binary Systems (SMBS)~\cite{82}. Since the hostile model is a SMBS, in this work we consider RVR for the network reliability estimation.
  
In the Generalized Steiner Problem (GSP), the goal is to communicate a given subset of terminal-nodes at the minimum cost, 
meeting connectivity requirements either by link-disjoint (GSP-EC) or node-disjoint (GSP-NC) paths. 
Since the problem is $\mathcal{NP}$-Hard, the literature offers approximation algorithms as well as metaheuristics. 
Agrawal, Klein and Ravi~\cite{32} developed an approximation algorithm with logarithmic factor for the GSP-EC. 
Jain~\cite{33} presented a factor-2 approximation algorithm for the GSP-EC, 
using the primal-dual schema for linear programming. 
A deep inapproximability result for the GSP-NC without Steiner nodes was introduced by Kortsarz in~\cite{34}. 
%We warn the reader that the many authors identify the GSP with an alternative acronym, 
%known as the Survivable Network Design Problem (SNDP). In~\cite{76} a stochastic version of the GSP is tackled, where the cost is considered a random variable, and  the goal is to minimize its expected value. A branch and cut shows to speed-up the CPU time. 
In~\cite{99} an enumeration of optimal solutions for the GSP is carried out with a compact data structure, called 
Zero-Suppressed Binary Decision Diagrams (ZDD). The authors show that this method works for several real-world 
instances. Heuristics are also available for the GSP. Sartor and Robledo developed a GRASP methodology to address the 
GSP-EC~\cite{65}. In~\cite{67}, S. Nesmachnow presents an empirical evaluation of several simple metaheuristics (VNS is included) to address the GSP, with promising results. 
%In~\cite{68}, M. Pedemonte and H. Cancela developed an Ant Colony Optimization (ACO) to solve the GSP using parallel computing in order to reduce the CPU-time. In~\cite{71}, another proposal of ACO for the GSP is presented to tackle the GSP in general graphs, outperforming previous heuristics. 
Several implementations of VNS have been developed for the particular Traveling Salesman Problem as well, showing that VNS is competitive. Exact solutions for the TSP and extensions can also be found in~\cite{61}. 
The CPU-times provided by the exact solutions are longer than the heuristics, and in particular VNS proposal for the TSP.

\section{Problem and Complexity}\label{problem}
In this section, we first present a general description of the GSPNCHR. Then, a formal combinatorial optimization problem is introduced, and the hardness is established.

\begin{definition}[GSPNCHR]
Consider a simple undirected graph $G=(V,E)$, terminal-set $T \subseteq V$, link-costs $\{c_{i,j}\}_{(i,j) \in E}$ 
and connectivity requirements $R=\{r_{i,j}\}_{i,j \in T}$. Further, we assume that both links and non-terminal (Steiner) nodes 
fail with respective probabilities $P_E=\{p_e\}_{e\in E}$ and $P_{V-T}=\{p_v\}_{v\in V-T}$. 
Given a reliability threshold $p_{min}$, the goal is to build 
a minimum-cost topology $G_S \subseteq G$ meeting both the connectivity requirements 
$R$ and the reliability threshold: $R_{K}(G_S) \geq p_{min}$, being $K=T$ the terminal-set.
\end{definition}

Recall that the $K$-Terminal reliability is the probability that all the terminals belong to the same component, after 
node and link failures. The exact computation of the reliability $R_K(G)$ is $\mathcal{NP}$-Hard~\cite{9}. 
Consider an instance $(G,C,R,T,P_E,P_{V-T},p_{min})$ of the GSPNCHR, and the following decision variables:

\[
    y_{(i,j)}^{u,v}=\left\{
                \begin{array}{ll}
1 & \textit{if} (i,j)\in E \, \, \textit{is used in a path} \, \, u-i-j-v\\
0 & \textit{otherwise}
                \end{array}
              \right.
  \]
\[
    x_{(i,j)}=\left\{
                \begin{array}{ll}
1 & \textit{if}  (i,j)\in E \, \, \textit{is used in the solution}\\
0 & \textit{otherwise} 
                \end{array}
              \right.
  \]
\[
    \hat{x}_{i}=\left\{
                \begin{array}{ll}
1 & \textit{if the Steiner node} \, \, i \in V-T \, \, \textit{is used in the solution}\\
0 & \textit{otherwise}
                \end{array}
              \right.
  \]

Here, we introduce the GSPNCHR as the following combinatorial optimization problem:

\begin{align}
\min &\sum_{(i,j)\in E} c_{i,j}x_{i,j} \notag \\
s.t. \, \, x_{ij}&\geq y_{(i,j)}^{u,v}+y_{(j,i)}^{u,v} \, \, \forall \, (i,j)\in E, \, \forall u,v\in T, u\neq v \label{1}\\
\sum_{(u,i)\in E}y_{(u,i)}^{u,v} &\geq r_{u,v} \, \, \forall \, u,v\in T, \, u\neq v \label{2}\\
\sum_{(j,v)\in E}y_{(j,v)}^{u,v} &\geq r_{u,v} \, \, \forall \, u,v\in T, \, u\neq v \label{3}\\
\sum_{(i,p)\in I(p)}y_{(i,p)}^{u,v}  - \sum_{(p,j)\in I(p)}y_{(p,j)}^{u,v}&\geq 0, \, \forall p\in V-\{u,v\}, \, \forall u,v\in T, \, u\neq v \label{4}\\
\sum_{(s,i)\in E} x_{s,i} &\leq M \hat{x}_{s}, \, \forall s\in V-T \label{5}\\
R_{K}(G_S) &\geq p_{min} \label{6}\\
x_{(i,j)} &\in \{0,1\} \, \forall (i,j)\in E \label{7}\\
\hat{x}_{i} &\in \{0,1\} \, \forall i \in V-T  \label{8}\\
 y_{(i,j)}^{u,v} &\in \{0,1\} \, \forall (i,j)\in E, \, \forall u,v \in T, \, u\neq v \label{9}
\end{align}

The goal is to minimize the global cost of the solution. The set of Constraints~\ref{1} state that links are one-way. 
The connectivity requirements are expressed by means of Constraints~\ref{2}~and~\ref{3}. 
Constraints~\ref{4} represent Kirchhoff law, or flow conservation. Constraints~\ref{5} state that an incident link 
to a Steiner node can be used only if the Steiner node is considered in the solution. Observe that $M$ is a large real number; $M=|E|$ can be used in the model without loss of generality. The minimum reliability threshold is established with Constraint~\ref{6}, being 
$G_S \subseteq G$ the subraph with all the constructed links $x_{i,j}$. Finally, the set of constraints~\ref{7}-\ref{9} state that all the decision variables belong to the binary set $\{0,1\}$. Now, we establish the hardness for the GSPNCHR.
\begin{theorem}\label{hard-problem}
The GSPNCHR belongs to the class of $\mathcal{NP}$-Hard problems.
\end{theorem}
\begin{proof}
By inclusion. Recall that Hamilton Tour belongs to Karp list of $\mathcal{NP}$-Complete problems~\cite{9}. 
Consider a simple graph $G=(V,E)$. Consider the \emph{trivial instance} $(G,C,R,T,P_E,P_{V-T},p_{min})$ with 
unit costs, perfect nodes/links, no Steiner nodes and requirements $r_{i,j}=2$ for all $i,j \in V$. 
The cost is not greater than $n=|V|$ if and only if $G$ has a Hamilton tour. 
\end{proof}
The GSPECHR is also $\mathcal{NP}$-Hard; the proof is analogous. Theorem~\ref{hard-problem} can be strengthened considering strong inapproximability results~\cite{49}.\\

In order to tackle the GSPNCHR, first we provide full solution for the relaxed version without the reliability threshold, 
this is, without Constraint~\ref{6}. Then, we count the number of feasible solutions that meet that constraint. We use this approach, since we want to determine if the topological robustness has an impact in the resulting network reliability. 


\section{Algorithmic Proposal}\label{solution}
GRASP and VND are well known metaheuristics that have been successfully used to solve many hard combinatorial optimization problems. GRASP is a powerful multi-start process which operates in two phases~\cite{51}. A feasible solution is built 
in a first phase, whose neighborhood is then explored in the Local Search Phase~\cite{51}. The second phase is usually enriched by means of different variable neighborhood structures. For instance, VND explores several neighborhood structures in a deterministic order. Its success is based on the simple fact that different neighborhood structures do not usually have the same local minimum. Thus,  the resulting solution is simultaneously a locally optimum solution under all the neighborhood structures. The reader is invited to consult the comprehensive Handbook of Heuristics for further information~\cite{50}. Here, we develop a GRASP/VND methodology.

\subsection{General Scheme}
A pseudocode of our full proposal is presented in Figure~\ref{MainAlgorithm}. 
It receives the ground graph $G_B$, a number of iterations $iter$ and a positive integer 
$k$ to find the $k$ shortest paths during the Construction Phase, a reliability threshold $p_{min}$, 
the elementary reliabilities $P_E$, $P_{V-T}$ and number of iterations $simiter$ during the simulations carried out in the Reliability Phase. If the resulting solution respects Constraint~\ref{6}, it is included 
in the set $sol$, that is returned in Line~10. Observe that RVR method is considered in order to test this reliability constraint~\cite{85}. Our goal is to determine how many solutions for the relaxed problem 
meet Constraint~\ref{6}, as a function of the robustness (connectivity matrix $R$, elementary reliabilities and threshold 
$p_{min}$). 

\begin{figure}[H]
\begin{algorithm}[H]
%\floatname{algorithm}{Algoritmo}
\caption{$sol = NetworkDesign(G_B,iter,k,p_{min},P_E,P_{V-T},simiter)$}
\begin{algorithmic}[1]
\STATE $i \leftarrow 0; \, P \leftarrow \emptyset; \, sol \leftarrow \emptyset$
\WHILE {$i < iter$}
\STATE $\overline{g} \leftarrow Construction(G_B,P,k)$
\STATE $g_{sol} \leftarrow VND(\overline{g},P)$
\STATE $reliability \leftarrow RVR(g_{sol},P_E,P_{V-T},simiter)$
\IF{$reliability > p_{min}$}
\STATE $sol \leftarrow sol \cup \{g_{sol}\}$
\ENDIF
\ENDWHILE
\RETURN $sol$
\end{algorithmic}
\end{algorithm}
\caption{Pseudocode for the main algorithm: $NetworkDesign$.\label{MainAlgorithm}}
\end{figure}

\subsection{Construction Phase}
%In a trade-off between simplicity and effectiveness, a Greedy Randomized solution has been developed~\cite{8,11}. 
This algorithm trades simplicity and effectiveness, building paths iteratively. 
Figure~\ref{const} receives the ground graph $G_B$, the matrix with link-costs $C$, 
the connectivity matrix $R$, and the parameter $k$. 
Denote $S_{D}^{(I)}$ the set of terminal nodes, following the terminology of the backbone design from Wide Area Networks. 
In Line~1, the solution $g_{sol}$ is initialized only with the terminal nodes $S_{D}^{I}$ 
without links, $M=\{m_{i,j}\}_{i,j\in T}$ stores the unsatisfied requirements, 
so initially $m_{i,j}=r_{i,}$ for all $i,j\in S_{D}^{(I)}$, and 
the matrix $P=\{P_{i,j}\}_{i,j\in S_{D}^{(I)}}$ that represents the collection of node-disjoint paths is empty for all $P_{i,j}$. Additionally, the matrix $A=\{A_{i,j}\}_{i,j\in S_{D}^{(I)}}$  that controls 
the number of attempts that the algorithm fails to find $r_{i,j}$ node-disjoint paths 
between $i,j$ is initialized correspondingly: $A_{i,j}=0\, \forall i, j \in S_{D}^{(I)}$. 

\begin{figure}[H]
\begin{algorithm}[H]
%\floatname{algorithm}{Algoritmo}
\caption{$(sol,P) = Construction(G_B,C,R,k)$}
\begin{algorithmic}[1]
\STATE $g_{sol} \leftarrow (S_D^{(I)},\emptyset)$; $m_{i,j}\leftarrow r_{i,j}$; $P_{i,j}\leftarrow \emptyset, \forall i,j \in S_{D}^{(I)}$; $A_{i,j}\leftarrow 0, \forall i,j \in S_{D}^{(I)}$
\WHILE {$\exists \, m_{i,j}>0: A_{i,j}<MAXATTEMPTS$}
\STATE $(i,j) \leftarrow ChooseRandom(S_{D}^{(I)}: m_{i,j}>0)$
\STATE $\overline{G} \leftarrow G_B \setminus P_{i,j}$
\FORALL {$(u,v)\in E(\overline{G})$}
\STATE $\overline{c}_{u,v} \leftarrow c_{u,v} \times 1_{\{(u,v) \notin g_{sol}\}}$
\ENDFOR
\STATE $L_p \leftarrow KSP(k,i,j,\overline{G},\overline{C})$
\IF{$L_p=\emptyset$}
\STATE $A_{i,j} \leftarrow A_{i,j}+1$; $P_{i,j} \leftarrow \emptyset$; $m_{i,j}\leftarrow r_{i,j}$ 
\ELSE 
\STATE $p \leftarrow SelectRandom(L_p)$; $g_{sol} \leftarrow g_{sol} \cup \{p\}$
\STATE $P_{i,j} \leftarrow P_{i,j} \cup \{p\}$; $m_{i,j} \leftarrow m_{i,j}-1$
\STATE $(P,M) \leftarrow GeneralUpdateMatrix(g_{sol},P,M,p,i,j)$
\ENDIF
\ENDWHILE
\RETURN $(g_{sol},P)$
\end{algorithmic}
\end{algorithm}
\caption{Pseudocode for the Construction Phase. \label{const}}
\end{figure}

The purpose of the \textit{while-loop} (Lines~2-13) is to fulfill all the connectivity 
requirements in a randomized fashion. Observe that we selected a large Restricted Candidate List (RCL) in 
our GRASP proposal for diversification purposes. 
A pair of terminals $(i,j)$ is uniformly picked at random from the set $S_{D}^{(I)}$, provided 
that $m_{i,j}>0$ (Line 3). The graph $\overline{G}$ defined in Line~4 discards the nodes 
that were already visited in the previous paths. Therefore, if we find some path between $i$ and 
$j$ in $\overline{G}$, it will be included. In the \textit{for-loop} of Lines~5-7, an auxiliary matrix with the costs $\overline{C}=\overline{c_{i,j}}$ allows to use already existent links from $g_{sol}$ without additional cost, and add them to build a new node-disjoint path. The KSP from $i$ to $j$ are computed in Line~8 using Yen algorithm~\cite{14}, that finds the $k$-Shortest Paths between two fixed nodes in a graph. In Line~9, we test if the list $L_p$ is empty. In this case we re-initialize $P_{i,j}$, $m_{i,j}$, and add a unit to $A_{i,j}$, since $i$ and $j$ belong to different connected components. If the list $L_p$ is not empty, a path $p$ is uniformly picked from the list $L_p$, 
and it is included in the solution (Line~12). The path $p$ is added to $P_{i,j}$, and the 
requirement $m_{i,j}$ is decreased a unit (Line~13). The addition of the path $p$ could 
build node-disjoint paths from different terminals. Consequently, the function $GeneralUpdateMatrix$ finds these new paths. $Construction$ returns a feasible solution $g_{sol}$ equipped with all the 
sets $P=\{P_{i,j}\}_{i,j \in S_{D}^{(I)}}$ of node-disjoint pairs between the different terminals 
(Line~17). The reader can observe that $Construction$ returns a feasible solution for the GSPNC, which is the 
relaxed version of the GSPNCHR. 

\subsection{Local Search Phase - VND}
The goal is to combine a rich diversity of neighborhoods in order to obtain an output that is locally optimum solution for every feasible neighborhood. Here, we consider three neighborhood structures to build a VND~\cite{50}.  
First, the concept of key-nodes, key-paths and key-trees are in order: 
\begin{definition}[key-node]
A key-node in a feasible solution $v \in g_{sol}$ is a Steiner (non-terminal) node with degree three or greater.
\end{definition}

\begin{definition}[key-path]
A key-path in a feasible solution $p \subseteq g_{sol}$ is an elementary path 
where all the intermediate nodes are non-terminal with degree 2 in $g_{sol}$, 
and the extremes are either terminals or key-nodes.
\end{definition}

A feasible solution $g_{sol}$ accepts a decomposition into key-paths: $K_{g_{sol}}=\{p_1,\ldots,p_h\}$. 
 
\begin{definition}[key-tree]
Let $v \in g_{sol}$ be a key-node belonging to a feasible solution $g_{sol}$. 
The key-tree associated to $v$, denoted by $T_v$, is the tree composed by all the 
key-paths that meet in the common end-point (i.e., the key-node $v$).
\end{definition}

Now, we are in conditions to define three neighborhood structures that combine the previous concepts. 
Consider a feasible solution $g_{sol}$ for the GSPNC. 

\begin{definition}[Neighborhood Structure for key-paths]
Given a key-path $p \in g_{sol}$, a neighbor-solution is 
${\hat{g}}_{sol} = \{g_{sol} \setminus p \} \cup \{\hat{p}\}$, 
where $\hat{p}$ is other path that connects the extremes from $p$.  
The neighborhood of key-paths from $g_{sol}$ is composed by the previous operation 
to the possible members belonging to $K_{g_{sol}}$. 
\end{definition}

\begin{definition}[Neighborhood Structure for key-tree]
Consider the key-tree $T_v \in g_{sol}$ rooted at the key-node $v$.  
A neighbor of $g_{sol}$ is $\hat{g}_{sol} = \{ g_{sol}\setminus T_v \} \cup \{T\}$, being 
$T$ another tree that replaces $T_v$ with identical leaf-nodes. 
\end{definition}

\begin{definition}[Neighborhood Structure for key-path replacement]
Given a key-path $p \subseteq g_{sol}$, a neighbor solution for $g_{sol}$ is 
$\hat{g}_{sol} = \{ g_{sol}\setminus p \}\cup \{m\}$, 
being $m$ the set of nodes and links that will be added to preserve the feasibility of ${\hat{g}}_{sol}$.  
\end{definition}

Our full algorithm $NetworkDesign$ considers a classical VND implementation, calling the three respective local searches in order, after the $Construction$ phase:
\begin{enumerate}
\item $KeyPathLocalSearch$
\item $KeyTreeLocalSearch$
\item $SwapKeyPathLocalSearch$
\end{enumerate}
This order was selected by computational reasons: the last one is the most demanding in terms of CPU, while the former 
is the most simple. The respective pseudocodes for the different local searches are presented in Figures~\ref{alg-kpls}-\ref{alg-kpls2}. It is worth to remark that these local searches take effect only if the resulting solution is both feasible and cheaper than the original one. The respective codes from each local search are self-explanatory, and strictly follow  the corresponding neighborhood structures, trying to find better replacements. For completeness, two auxiliary functions 
called during these searches are here explained, in terms of inputs and outputs. 
We invite the reader to consult~\cite{117} for implementation details:
\begin{itemize}
\item $GeneralRecConnect$: receives the ground graph $G_B$, cost-matrix $C$, current solution $g_{sol}$ and a 
key-node $v$. It tries to replace the key-tree $T_v$ with a better key-tree $T$ spanning the same leaf-nodes, preserving feasibility. It returns another solution and a boolean $improve$ (if $improve=0$, an identical solution is returned).
\item $FindSubstituteKeyPath$: receives the current solution $g_{sol}$, the key-path $p$ and a matrix $P$ with the 
collection of disjoint path between the terminals. It replaces the current path $p$ by $\hat{p}$, exploiting the information given by $P$ in order to reconstruct a new feasible solution. If this solution is cheaper, it returns $improve=1$ 
and the resulting solution (otherwise, an identical solution is returned). 
\end{itemize}

%%% PROCEDURE KeyPathLocalSearch
\begin{figure}[H]
\begin{algorithm}[H]
%\floatname{algorithm}{Algoritmo}
\caption{$g_{sol} = KeyPathLocalSearch(G_B,C,g_{sol})$}
\begin{algorithmic}[1]
\STATE $improve \leftarrow TRUE$
\WHILE {$improve$}
\STATE $improve \leftarrow FALSE$
\STATE $K(g_{sol}) \leftarrow \{p_1,\ldots,p_h\}$ /* Key-path decomposition of $g_{sol}$ */
%\COMMENT{Key-path decomposition of $g_{sol}$}
\WHILE{\textbf{not} $improve$ \textbf{and} $\exists$ \textbf{key-paths not analyzed}}
\STATE $p \leftarrow(K(g_{sol}))$ /* Path not analyzed yet, with extremes $u$ and $v$ */
\STATE $\hat{\mu} \leftarrow <NODES(p) \cup S_D\setminus NODES(g_{sol}) > $ /* Induced subgraph $\hat{\mu}$ */
\STATE $\hat{p} \leftarrow Dijkstra(u,v,\hat{\mu})$
\IF{$COST(\hat{p}) < COST(p)$}
\STATE $g_{sol} \leftarrow \{ g_{sol}\setminus p \} \cup \{\hat{p}\}$
\STATE $improve \leftarrow TRUE$
\ENDIF
\ENDWHILE
\ENDWHILE
\RETURN $g_{sol}$
\end{algorithmic}
\end{algorithm}
\caption{Pseudocode for Local Search 1: $KeyPathLocalSearch$.\label{alg-kpls}}
\end{figure}

%
%
%$KeyPathLocalSearch$ builds neighbor solutions with an iterative replacement of key-paths with 
%the same key-nodes, preserving feasibility. The process is repeated until no additional improvements are feasible, and a locally-optimum solution is met for this neighborhood system. 
%A pseudocode for $KeyPathLocalSearch$ is presented in Figure~\ref{alg-kpls}. 
%It receives the ground graph $G_B$, link-costs $C$ and a feasible solution $g_{sol}$. 
%The variable $improve$ is set to TRUE in Line~1. This variable is useful to determine whether there exists 
%an improvement or not during the replacement of key-paths of the algorithm. The \textit{while-loop} 
%of Lines~2-14 looks for neighbor solutions, studying each key-path from the solution $g_{sol}$ and 
%replacing by new key-paths in order to reduce the cost of the global solution, preserving feasibility. 
%Each iteration works as follows. The variable $improve$ is set to $FALSE$ in Line~3. The decomposition of $g_{sol}$ 
%into key-paths is found in Line~4. The internal \textit{while-loop} of Lines~5-13 studies the key-paths from 
%$K(g_{sol})$ one-by-one, looking for a cheaper and feasible replacement. A key-path that 
%was not previously studied $p\in K (g_{sol})$ is uniformly picked at random in Line~6. 
%The network $\hat{\mu}$ induced by the nodes $NODES(p) \cup S_D\setminus NODES(g_{sol})$ 
%is computed in Line~7 (recall that $S_D$ is the set of terminal nodes following the traditional terminology from WAN network design). The set on the right, $\overline{S}=S_D\setminus NODES(g_{sol})$, is precisely the 
%terminal nodes not belonging to $g_{sol}$. Observe that $\hat{\mu}$ does not possess nodes from $g_{sol}\setminus p$, except for $u$ and $v$. Then, all the paths connecting $u$ and $v$ belonging to $\hat{\mu}$ re-establish the feasibility of 
%$g_{sol}\setminus p$. Consequently, the shortest path from $u$ to $v$ in $\hat{\mu}$ is found in Line~8. 

 


%
%The cost between $\hat{p}$ and the original path $p$ is compared in Line~9. If $\hat{p}$ is cheaper than $p$, 
%the key-path $p$ is correspondingly replaced by $\hat{p}$ in $g_{sol}$ (Line~10), and 
%the variable $improve$ is set to $TRUE$ (Line~11), in order to re-start the local search from Line~2. On the other hand, if $\hat{p}$ is not cheaper than $p$, the \textit{while-loop} of Lines~5-13 picks another 
%key-path not studied before, until all key-paths are studied. The process is finished as soon as there are 
%no possible improvements, or there are no key-paths to study. 
%The best neighbor solution $g_{sol}$ is returned in Line~15.

%\subsubsection{Local Search 2: KeyTreeLocalSearch}
%\begin{definition}[Neighborhood Structure for key-tree]
%Consider the key-tree $T_v \in g_{sol}$ rooted at the key-node $v$, where $g_{sol}$ is a feasible solution. 
%A neighbor of $g_{sol}$ is $\hat{g}_{sol} = \{ g_{sol}\setminus T_v \} \cup \{T\}$, being 
%$T$ another tree that replaces $T_v$, with identical leaf-nodes, and preserving feasibility. 
%The neighborhood of $g_{sol}$ is composed by all the neighbor solutions obtained 
%with an iterative application of the previous operations, for the different key-trees belonging to $g_{sol}$.
%\end{definition}

\begin{figure}[H]
\begin{algorithm}[H]
%\floatname{algorithm}{Algoritmo}
\caption{$g_{sol} = KeyTreeLocalSearch(G_B,C,g_{sol})$}
\begin{algorithmic}[1]
\STATE $improve \leftarrow TRUE$
\WHILE {$improve$}
\STATE $improve \leftarrow FALSE$
\STATE $ X \leftarrow KeyNodes(g_{sol})$ /* Key-nodes from $g_{sol}$ */
\STATE $\overline{S} \leftarrow S_D \setminus NODES(g_{sol})$
\WHILE{\textbf{not} $improve$ \textbf{and} $\exists$ \textbf{key-nodes not analyzed}}
\STATE $v \leftarrow X$ /* Key-node not analyzed yet */
\STATE $[g_{sol},improve] \leftarrow GeneralRecConnect(G_B,C,g_{sol},v,\overline{S})$
\ENDWHILE
\ENDWHILE
\RETURN $g_{sol}$
\end{algorithmic}
\end{algorithm}
\caption{Pseudocode for Local Search 2: $KeyTreeLocalSearch$.\label{alg-ktls}}
\end{figure}

%Based on this neighborhood structure, we define a second local search that replaces key-trees 
%(note that the previous local search was a replacement of key-paths). 
%Figure~\ref{alg-ktls} presents a pseudocode for $KeyTreeLocalSearch$. 
%The rationale is to iteratively build neighbor solutions using a replacement of key-trees, preserving 
%feasibility. The process is repeated until no possible improvement exists. 
%It receives the ground graph $G_B$, link-costs $C$ and the feasible solution $g_{sol}$. 
%The variable $improve$ is set to $TRUE$ (Line~1). The \textit{while-loop} of Lines~2-10 looks 
%for better neighbors solutions, studying each key-node from the current solution $g_{sol}$, and 
%a replacement takes place if corresponds. The \textit{while-loop} is repeated whenever an improvement is 
%found. Each iteration works in the following manner. The variable $improve$ is set to $FALSE$ in Line~3. 
%The set $X$ of all the key-nodes from $g_{sol}$ are obtained in Line~4. In Line~5, 
%the set of Steiner nodes $\overline{S}$ not belonging to $g_{sol}$ are computed. 
%The internal \textit{while-loop} of Lines~6-9 studies every key-node belonging to $X$, together with 
%its associated key-tree, trying to find a cheaper key-tree for replacement. 
%A key-node $v \in X$ is uniformly picked at random in Line~7. The algorithm 
%called $General\_RecConnect$ is called in Line~8, to find a replacement that is both feasible and cheaper than $T_v$. 
%If this search is successful, this algorithm returns an improved neighbor solution in Line~8, and the solution is 
%updated in the same line. Additionally, the variable $improve$ is set to $TRUE$, 
%and the local searches proceeds in Line~2. If $General\_RecConnect$ fails to find a replacement, the internal 
%\textit{while-loop} considers an alternative key-node not previously studied, 
%or this loop is finished if all the key-nodes were studied. 
%The process is finished as soon as there are no possible improvements, or there are no key-trees to study. 
%The best neighbor solution $g_{sol}$ is returned in Line~11. 
%
%\subsubsection{Local Search 3: SwapKeyPathLocalSearch}
%\begin{definition}[Neighborhood Structure for key-path replacement]
%Given a key-path $p \subseteq g_{sol}$ from a feasible solution $g_{sol}$, 
%a neighbor solution for $g_{sol}$ is $\hat{g}_{sol} = \{ g_{sol}\setminus p \}\cup \{m\}$, 
%being $m$ the set of nodes and links that will be added to preserve the feasibility of the 
%solution ${\hat{g}}_{sol}$.  
%The set $m$ could be empty, if the deletion of a key-path from $g_{sol}$ is already feasible. 
%The neighbor of key-paths from $g_{sol}$ is composed by the previous neighbor solutions 
%to each of the different key-paths belonging to the $K(g_{sol}) = \{p_1,\ldots,p_h\}$, 
%the decomposition of $g_{sol}$ into key-paths. 
%\end{definition}
%
%$SwapKeyPathLocalSearch$ iteratively builds neighbor solutions, removing 
%key-paths and reconstructing a feasible solution using the information stored in the 
%matrix $P$ (of node-disjoint paths), generated by $Greedy$ algorithm during the Construction phase. The process 
%is finished only when no feasible improvements are possible. Figure~\ref{alg-kpls2} shows a pseudocode for $SwapKeyPathLocalSearch$. It receives 
%the ground graph $G_B$, the link-costs $C$, a feasible solution $g_{sol}$ and the matrix with the node-disjoint paths $P$ obtained by the Greedy randomized construction. The variable $improve$ is set to TRUE in Line~1. This variable is useful to determine whether there exists an improvement or not during the replacement of key-paths by paths. The \textit{while-loop} 
%of Lines~2-9 looks for neighbor solutions, studying each key-path from the solution $g_{sol}$ and 
%replacing by nodes and links, or simply deleting the key-path improving the cost, whenever the resulting network 
%is feasible. Each iteration works as follows. The variable $improve$ is set to $FALSE$ in Line~3. The decomposition 
%$K(g_{sol})$  of $g_{sol}$ into key-paths is found in Line~4. 
%
%The internal \textit{while-loop} of Lines~5-8 studies the key-paths from 
%$K(g_{sol})$ one-by-one, looking for a cheaper and feasible replacement with nodes and links. A key-path that 
%was not previously studied $p\in K (g_{sol})$ is uniformly picked at random in Line~6. 
%The routine $FindSubstituteKeyPath$ is called in Line~7. It deletes the key-path from the current solution and tries to re-connect the extremes by nodes and links, preserving feasibility. If, in addition, 
%the resulting solution is cheaper, the variable $improve$ is set to $TRUE$, and the solution is effectively replaced. Otherwise,  the following key-path is studied. 
%The process is finished as soon as there are no possible improvements, by replacements from key-paths 
%to nodes and links , or there are no key-paths to study. 
%The best neighbor solution $g_{sol}$ is returned in Line~10. 

%%% Procedure SwapKeyPathLocalSearch
\begin{figure}[H]
\begin{algorithm}[H]
%\floatname{algorithm}{Algoritmo}
\caption{$g_{sol} = SwapKeyPathLocalSearch(G_B,C,g_{sol},P)$}
\begin{algorithmic}[1]
\STATE $improve \leftarrow TRUE$
\WHILE {$improve$}
\STATE $improve \leftarrow FALSE$
\STATE $K(g_{sol}) \leftarrow \{p_1,\ldots,p_h\}$ /* Key-path decomposition of $g_{sol}$ */
\WHILE{\textbf{not} $improve$ \textbf{and} $\exists$ \textbf{key-paths not analyzed}}
\STATE $p \leftarrow(K(g_{sol}))$ /* Path not analyzed yet */
\STATE $(g_{sol},improve) \leftarrow FindSubstituteKeyPath(g_{sol},p,P)$
\ENDWHILE
\ENDWHILE
\RETURN $g_{sol}$
\end{algorithmic}
\end{algorithm}
\caption{Pseudocode for Local Search 3: $SwapKeyPathLocalSearch$.\label{alg-kpls2}}
\end{figure}

\subsection{Reliability Phase - RVR}
In the last step, RVR is introduced in order to determine if Constraint~\ref{6} is met. The reader is invited to consult authoritative works on RVR and cites therein~\cite{85}.  

%\clearpage

\section{Numerical Results}\label{results}
%\subsection{Test-Set}
In order to understand the effectiveness of this proposal, an extensive computational study was carried out using our main algorithm $NetworkDesign$. The experimental analysis was carried out in a Home-PC (Pentium Core I5, 6GB). Since there are no benchmark for our specific problem we adapted the well-known TSPLIB instances, adding node/link failure probabilities and node connectivity requirements. We selected $k=5$ for $Construction$, which showed acceptable results in a training set. In our reliability-centric design, we fixed $p_{min}=0.8$; lower values make no sense. The elementary reliabilities for both Steiner nodes and links are close to the unit, since we are focused on the design of highly-reliable networks. Specifically, the nine combinations for $p_{v},p_{e} \in \{0.99, 0.97,0.95\}$ were considered in different instances, being $p_v$ and $p_e$ the elementary reliabilities for Steiner nodes and links $e=(i,j)$ respectively. The number of iterations for $NetworkDesign$ is established in $iter=100$, and the number of iterations for the RVR method is $10^4$. 

We want to understand the sensibility of the solution to perturbations in the elementary reliabilities. 
Therefore, different values for the elementary reliabilities for both Steiner nodes and links were used. Table~\ref{res} shows the results for each adapted TSPLIB instance. Each column contains, respectively, name of the TSPLIB instance, percentage of terminal nodes (\% $T$), 
relative improvements of $Construction$  (\% $IC$) and $VND$ phases (\%$IVND$), in relation to the cost of the corresponding input graphs, CPU-time per iteration of $NetworkDesign$, 
reliability estimation $\overline{R}$ and estimated variance $\overline{Var}$. 
From Table~\ref{res}, we can appreciate that the cost of the resulting graph after the $Construction$ is practically one-half the cost of its input. The improvement of $VND$ is consistently bounded between 30.55\% and 39.45\%, according to the instance and its characteristics on the test-set. The minimum threshold $p_{min}=0.8$ is widely exceeded in all the instances under study, considering the RVR 
estimation $\overline{R}$. The elementary reliabilities were established in $p_v=0.99$ and $p_e=0.95$ respectively for nodes and links, and the range of reliabilities is bounded between $0.8231$ and $0.967$, meeting the reliability constraint. The estimated variance 
$\overline{Var}$ is reduced in average in all the instances under study. These facts highlight the activity of the $VND$ phase, the accuracy of RVR and the global effectiveness of our proposal. Furthermore, the CPU times are acceptable, even under large-sized graphs with 400 nodes.

Tables~\ref{answer2a}~and~\ref{answer2b} illustrate the number of feasible solutions 
obtained when we fix the elementary node-reliability and modify the link-reliabilities, and vice-versa. The suffix $TXY$ in each instance indicates the percentage $XY$\% of 
terminal nodes. The feasibility is 100\% in almost all the instances under study when 
both $p_e=p_v=0.99$. However, the feasibility is dramatically deteriorated as soon as 
the link-reliabilities are decreased (see the last column of Table~\ref{answer2a}). 
This effect is not pronounced when the node-reliabilities are reduced, as we can appreciate from the last column of Table~\ref{answer2b}. This fact shows that the system is robust under failures of Steiner nodes. 


\begin{center}
\begin{longtable}{|l|l|l|l|l|l|l|}
\caption{\textbf{GRASP/VND Effectiveness}}\label{res}\\ % is used to refer this table in the text
%\centering  % used for centering table

\hline \multicolumn{1}{|c|}{Instance} & \multicolumn{1}{c|}{\% $T$} & 
\multicolumn{1}{c|}{\% $IC$} & \multicolumn{1}{c|}{\% $IVND$}  &
\multicolumn{1}{c|}{\textbf{$CPU\, (s)$}} & \multicolumn{1}{c|}{$\overline{R}$}  &
\multicolumn{1}{c|}{$\overline{Var}$} \\ \hline 
\endfirsthead


\multicolumn{7}{c}%
{{\bfseries \tablename\ \thetable{}-- GRASP/VND Effectiveness (cont.)}} \\
\hline \multicolumn{1}{|c|}{Instance} & \multicolumn{1}{c|}{\% $T$} & 
\multicolumn{1}{c|}{\% $IC$} & \multicolumn{1}{c|}{\% $IVND$}  &
\multicolumn{1}{c|}{\textbf{$CPU\, (s)$}} & \multicolumn{1}{c|}{$\overline{R}$}  &
\multicolumn{1}{c|}{$\overline{Var}$} \\ \hline 
\endhead

\multicolumn{7}{c}%
{{\bfseries \tablename\ \thetable{} -- Numerical Results (cont.)}} \\
\hline \multicolumn{1}{|c|}{Instance} & \multicolumn{1}{c|}{\% $T$} & 
\multicolumn{1}{c|}{\% $IC$} & \multicolumn{1}{c|}{\% $IVND$}  &
\multicolumn{1}{c|}{\textbf{$CPU\, (s)$}} & \multicolumn{1}{c|}{$\overline{R}$}  &
\multicolumn{1}{c|}{$\overline{Var}$} \\ \hline 
\endhead

%\hline \multicolumn{7}{|r|}{{Continued on next page}} \\ \hline
\endfoot

%\hline \hline
\endlastfoot


%\hline	$Problem$   &	\% $T$ & \%$IG$& \% $IVNS$ & $CPU$ & $\overline{R}$ & $\overline{Var}$ \\
\hline	att48	&	20	&	99.27	&	34.61	&	11.466	&	0.967	&	7.608E-07	\\
\hline	att48	&	35	&	98.6	&	36.83	&	29.769	&	0.943	&	3.448E-06	\\
\hline	att48	&	50	&	98.22	&	37.1	&	65.904	&	0.927	&	5.322E-06	\\
\hline	berlin52	&	20	&	98.98	&	30.55	&	30.605	&	0.937	&	3.294E-06	\\
\hline	berlin52	&	35	&	99.06	&	33.93	&	33.433	&	0.938	&	3.19E-06	\\
\hline	berlin52	&	50	&	98.02	&	33.48	&	106.945	&	0.907	&	6.487E-06	\\
\hline	brazil58	&	20	&	98.92	&	31.96	&	62.377	&	0.885	&	6.722E-06	\\
\hline	brazil58	&	35	&	99.25	&	39.45	&	68.891	&	0.86	&	8.347E-06	\\
\hline	brazil58	&	50	&	98.75	&	35.26	&	103.553	&	0.91	&	7.093E-06	\\
\hline	ch150	&	20	&	99.76	&	37.51	&	222.552	&	0.8559	&	1.029E-05	\\
\hline	ch150	&	35	&	99.72	&	36.65	&	546.652	&	0.8803	&	9.033E-05	\\
%\hline	ch150	&	50	&	99.69	&	34.42	&	1203.054	&	88.8	&	8.974E-05	\\
%\hline	d198	&	20	&	99.9	&	32.22	&	320.142	&	NA	&	NA	\\
%\hline	d198	&	35	&	99.86	&	34.12	&	2086.376	&	NA	&	NA	\\
%\hline	d198	&	50	&	99.81	&	33.39	&	5548.639	&	NA	&	NA	\\
%\hline	eil51	&	20	&	99.34	&	38.79	&	14.87	&	96	&	1.183E-06	\\
%\hline	eil51	&	35	&	98.54	&	36.11	&	39.017	&	94.2	&	3.736E-06	\\
%\hline	eil51	&	50	&	98.56	&	37.32	&	44.798	&	93.7	&	4.284E-06	\\
%\hline	gr137	&	20	&	99.79	&	36.31	&	137.496	&	NA	&	NA	\\
%\hline	gr137	&	35	&	99.71	&	34.18	&	404.061	&	NA	&	NA	\\
%\hline	gr137	&	50	&	99.68	&	34.61	&	976.369	&	NA	&	NA	\\
\hline	gr202	&	20	&	99.89	&	32.43	&	528.162	&	0.8231	&	1.224E-05	\\
\hline	gr202	&	35	&	99.75	&	34.56	&	3511.698	&	0.8414	&	1.11E-05	\\
\hline	gr202	&	50	&	99.74	&	33.36	&	9505.629	&	0.8303	&	1.279E-05	\\
%\hline	kroA100	&	20	&	99.61	&	36.77	&	44.225	&	NA	&	NA	\\
%\hline	kroA100	&	35	&	99.53	&	38.23	&	101.498	&	88.97	&	8.525E-05	\\
%\hline	kroA100	&	50	&	99.45	&	35.89	&	280.833	&	NA	&	NA	\\
%\hline	kroA150	&	20	&	99.83	&	36.7	&	102.712	&	NA	&	NA	\\
%\hline	kroA150	&	35	&	99.75	&	36.3	&	412.97	&	NA	&	NA	\\
%\hline	kroA150	&	50	&	99.7	&	32.32	&	2035.062	&	NA	&	NA	\\
%\hline	kroB100	&	20	&	99.68	&	38.71	&	17.301	&	90.14	&	6.251E-05	\\
%\hline	kroB100	&	35	&	99.59	&	36.32	&	53.74	&	NA	&	NA	\\
%\hline	kroB100	&	50	&	99.49	&	34.98	&	191.722	&	NA	&	NA	\\
%\hline	kroB150	&	20	&	99.84	&	37.49	&	112.099	&	NA	&	NA	\\
%\hline	kroB150	&	35	&	99.77	&	36.05	&	665.676	&	NA	&	NA	\\
%\hline	kroB150	&	50	&	99.73	&	34.53	&	1327.528	&	NA	&	NA	\\
%\hline	kroB200	&	20	&	99.89	&	36.14	&	279.156	&	NA	&	NA	\\
%\hline	kroB200	&	35	&	99.84	&	35.06	&	2234.738	&	NA	&	NA	\\
%\hline	kroB200	&	50	&	99.8	&	33.82	&	7448.424	&	NA	&	NA	\\
%\hline	lin105	&	20	&	99.74	&	35.89	&	9.439	&	NA	&	NA	\\
%\hline	lin105	&	35	&	99.61	&	37.04	&	86.855	&	NA	&	NA	\\
%\hline	lin105	&	50	&	99.5	&	36.4	&	245.246	&	NA	&	NA	\\
%\hline	pr152	&	20	&	99.79	&	37.14	&	281.166	&	NA	&	NA	\\
%\hline	pr152	&	35	&	99.77	&	36.86	&	808.477	&	NA	&	NA	\\
%\hline	pr152	&	50	&	99.74	&	36.88	&	1673.465	&	NA	&	NA	\\
%\hline	rat195	&	20	&	99.88	&	37.31	&	280.948	&	NA	&	NA	\\
%\hline	rat195	&	35	&	99.82	&	34.7	&	1925.985	&	NA	&	NA	\\
%\hline	rat195	&	50	&	99.8	&	34.99	&	4599.873	&	NA	&	NA	\\
%\hline	st70	&	20	&	99.44	&	39.84	&	39.852	&	91.9	&	4.072E-06	\\
%\hline	st70	&	35	&	99.3	&	39.56	&	63.65	&	90.6	&	5.743E-06	\\
%\hline	st70	&	50	&	99.16	&	36.37	&	128.195	&	91.3	&	7.027E-06	\\
%\hline	tsp225	&	20	&	99.88	&	34.98	&	1658.773	&	84.75	&	1.141E-05	\\
%\hline	tsp225	&	35	&	99.85	&	34.65	&	4684.367	&	84.64	&	1.249E-05	\\
%\hline	tsp225	&	50	&	99.82	&	33.26	&	12088.726	&	87.19	&	1.092E-05	\\
%\hline	u159	&	20	&	99.81	&	35.84	&	333.263	&	NA	&	NA	\\
%\hline	u159	&	35	&	99.76	&	36.14	&	864.992	&	NA	&	NA	\\
%\hline	u159	&	50	&	99.75	&	35.61	&	1278.13	&	NA	&	NA	\\
%\hline	rd100	&	20	&	99.68	&	37.15	&	22.421	&	NA	&	NA	\\
%\hline	rd100	&	35	&	99.5	&	34.54	&	126.822	&	NA	&	NA	\\
%\hline	rd100	&	50	&	99.42	&	36.13	&	245.827	&	NA	&	NA	\\
\hline	rd400	&	20	&	99.94	&	35.84	&	88.214	&	0.8094	&	14.22E-05	\\
\hline	rd400	&	35	&	99.94	&	33.54	&	504.103	&	0.8537	&	11.89E-05	\\
\hline	rd400	&	50	&	99.93	&	33.16	&	980.701	&	0.8643	&	11.51E-05	\\
%\hline	berlin52(E)	&	20	&	98.45	&	25.25	&	34.209	&	99.3	&	4.848E-07	\\
%\hline	eil51(E)	&	20	&	98.47	&	28.45	&	29.623	&	99.6	&	2.707E-07	\\
%\hline	att48(E)	&	35	&	97.45	&	31.74	&	62.967	&	99.4	&	4.93E-07	\\
%\hline	st70(E)	&	35	&	98.52	&	31.87	&	135.508	&	99.3	&	6.549E-07	\\
%\hline	brazil58(E)	&	50	&	97.48	&	31.84	&	172.636	&	99.4	&	4.825E-07	\\
%\hline	eil51(E)	&	50	&	97.26	&	32.67	&	74.473	&	99.1	&	7.942E-07	\\
%\hline	kroB100(E)	&	20	&	99.37	&	30.25	&	39.255	&	99.87	&	1.219E-06	\\
%\hline	lin105(E)	&	20	&	99.33	&	31.95	&	64.409	&	NA	&	NA	\\
%\hline	kroA100(E)	&	35	&	98.99	&	35.88	&	225.505	&	99.81	&	1.828E-06	\\
%\hline	rd100(E)	&	35	&	99.15	&	35.3	&	130.008	&	NA	&	NA	\\
\hline Average     & NA    &   99.28   &  34.72   &    964.744 &  0.884 & 3.28E-05 \\
\hline
\end{longtable}
\end{center}



\begin{table}
\caption{Feasible solutions with $R \geq 0.98$,  
$p_v=0.99$ fixed and variable link reliability} % title of Table
\centering  % used for centering table
\begin{tabular}{|c|c|c|c|c|} % centered columns 
\hline	Instance  &	$p_e=0.99$ & 	$p_e=0.97$ & 	$p_e=0.95$\\
\hline	att48 T20	&	100	&	90	&	12	\\
\hline	att48 T35	&	100	&	53	&	0	\\
\hline	att48 T50	&	100	&	20	&	0	\\
\hline	berlin52 T20	&	100	&	41	&	0	\\
\hline	berlin52 T35	&	100	&	50	&	0	\\
\hline	berlin52 T50	&	100	&	1	&	0	\\
\hline	brazil58 T20	&	99	&	15	&	0	\\
\hline	brazil58 T35	&	97	&	0	&	0	\\
\hline	brazil58 T50	&	100	&	5	&	0	\\
\hline	ch150 T20	&	100	&	0	&	0	\\
\hline	ch150 T35	&	100	&	0	&	0	\\
\hline	ch150 T50	&	100	&	0	&	0	\\
\hline	gr202 T20	&	99	&	0	&	0	\\
\hline	gr202 T35	&	100	&	0	&	0	\\
\hline	gr202 T50	&	100	&	0	&	0	\\
\hline	rd400 T20	&	100	&	0	&	0	\\
\hline	rd400 T35	&	100	&	0	&	0	\\
\hline	rd400 T50	&	100	&	0	&	0	\\
\hline  Average     & 99.72    &   15.28   &  0.67 \\
\hline
\end{tabular}
\label{answer2a} % is used to refer this table in the text
\end{table}

\begin{table}
\caption{Feasible solutions with $R \geq 0.98$, $p_e=0.99$ fixed 
and variable node-reliability} % title of Table
\centering  % used for centering table
\begin{tabular}{|c|c|c|c|c|} % centered columns 
\hline	Instance  &	$p_v=0.99$ & 	$p_v=0.97$ & 	$p_v=0.95$\\
\hline	tt48 T20	&	100	&	100	&	99	\\
\hline	att48 T35	&	100	&	98	&	96	\\
\hline	att48 T50	&	100	&	100	&	99	\\
\hline	berlin52 T20	&	100	&	100	&	80	\\
\hline	berlin52 T35	&	100	&	99	&	93	\\
\hline	berlin52 T50	&	100	&	100	&	100	\\
\hline	brazil58 T20	&	99	&	59	&	41	\\
\hline	brazil58 T35	&	97	&	43	&	9	\\
\hline	brazil58 T50	&	100	&	99	&	81	\\
\hline	ch150 T20	&	100	&	60	&	20	\\
\hline	ch150 T35	&	100	&	98	&	76	\\
\hline	ch150 T50	&	100	&	100	&	97	\\
\hline	gr202 T20	&	99	&	80	&	30	\\
\hline	gr202 T35	&	100	&	69	&	16	\\
\hline	gr202 T50	&	100	&	100	&	76	\\
\hline	rd400 T20	&	100	&	16	&	2	\\
\hline	rd400 T35	&	100	&	98	&	80	\\
\hline	rd400 T50	&	100	&	100	&	100	\\
\hline  Average     &   99.72    &   84.39   &  66.39 \\
\hline
\end{tabular}
\label{answer2b} % is used to refer this table in the text
\end{table}




\section{Conclusions and Trends for Future Work}\label{conclusions}
We studied the topological design of highly reliable networks. Our goal is to combine purely  deterministic aspects such as connectivity with probabilistic models coming from network reliability. For that purpose, the Generalized Steiner Problem with Node-Connectivity Constraints and Hostile Reliability (GSPNCHR) is here introduced. The GSPNCHR belongs to the class of $\mathcal{NP}$-Hard problems, since it subsumes the Generalized Steiner Problem (GSP). Therefore, exact methods are prohibitive, even for networks with moderate size. A GRASP/VND solution is here developed, which shows to be both flexible and effective. 
Since the reliability evaluation for the hostile model also belongs to the $\mathcal{NP}$-Hard class, we adopted an outstanding pointwise reliability estimation, known as Recursive Variance Reduction (RVR) method. 
This method is unbiased, accurate and it presents small variance, as the results show. The model is more sensible to link-failures rather than node-failures.

The interplay between topological network design and network reliability is not well understood yet. Some local searches were here proposed, essentially using key-path and key-tree replacements, in order to reduce costs preserving feasibility. A current research line is to introduce reliability-increasing transformations.  
The development of local searches that increase reliability and reduce costs would enrich the current solution. Another possibility for future work is to enrich the number of local searches and consider 
probabilistic transitions between them. 

\section{Acknowledgements}
This work is partially supported by Project ANII FCE\_1\_2019\_1\_156693 \emph{Teor\'ia y Construcci\'on de Redes de M\'axima  Confiabilidad}, MATHAMSUD 19-MATH-03 \emph{Rare events analysis in multi-component systems with dependent components} and
STIC-AMSUD ACCON \emph{Algorithms for the capacity crunch problem in optical networks}. 

%
%\tolerance=10000
%\emergencystretch=\maxdimen
%\hyphenpenalty=10000
%\hbadness=10000

\bibliographystyle{plain}
\bibliography{Biblio}
\end{document}
\grid
